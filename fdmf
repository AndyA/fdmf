#!/usr/bin/env perl
# Kurt Rosenfeld 2004, 2005, 2006
# GPL

use strict;
use warnings;

use Cwd;
use Digest::SHA1 qw( sha1 );
use File::Basename;
use File::Find;
use File::Spec;
use File::Which;
use FindBin;
use Getopt::Long;
use IPC::Run qw( run );
use Memoize;
use Storable;

use constant DBFILE => glob '~/.fdmf';

my %Opt = ( verbose => 0 );

memoize qw( find_prog );

find_prog( 'spline' );

GetOptions( 'verbose' => \$Opt{verbose} ) or usage( 1 );
usage( 2 ) unless @ARGV;

=head2 Data Representation

We store three hashes:

=over

=item 1 Filename hash C<< $DB->{f} >>

Maps a filename to a dev, inode pair

=item 2 File hash C<< $DB->{i} >>

Maps a dev, inode pair to an SHA1 hash of the file's contents.

=item 3 SHA1 hash C<< $DB->{h} >>

Maps an SHA1 hash to the perceptual hash information for the file 

=back

=cut

our $DB = get_db( DBFILE );
END { put_db( DBFILE, $DB ) if defined $DB }

fdmf( @ARGV );

sub mention(@) {
  print join( ' ', @_ ), "\n" if $Opt{verbose};
}

sub fdmf {
  my @obj = @_;
  find {
    wanted => sub {
      return unless -f;
      return if /^\./;
      return unless can_handle( $_ );
      process( $_ );
    },
    no_chdir => 1
  }, @obj;
}

sub process {
  my $file = File::Spec->rel2abs( $_[0] );

  return if exists $DB->{f}{$file};
  my $sig = file_sig( $file );
  $DB->{f}{$file} = $sig;

  return if exists $DB->{i}{$sig};
  my $hash = file_sha1( $file );
  $DB->{i}{$sig} = $hash;

  return if exists $DB->{h}{$hash};
  mention "Analysing $file";
  $DB->{h}{$hash} = sonic_reduce( $file );
}

sub sonic_reduce {
  my $f = shift;

  run(
    (
      $f =~ /\.gz$/i
      ? [ find_prog( 'gzip' ), '-cd', $f ]
      : [ find_prog( 'cat' ), $f ]
    ),
    '|',
    [
      find_prog( 'ffmpeg' ),
      '-i', '-', '-acodec', 'pcm_s16le', '-f', 's16le', '-'
    ],
    '2>',
    \( my $ffmpeg_err ),
    '|',
    [ find_prog( 'sonic_reducer', $FindBin::Bin ) ],
    '>',
    \( my $out )
  );

  chomp $out;
  my @data = split /\n/, $out;
  die "sonic_reducer produced strange results\n"
   unless @data == 768;

  return unpack 'H*', pack 'b*',
   join '', quantize( @data[ 0 .. 255 ] ),
   quantize( @data[ 256 .. 511 ] ),
   quantize( @data[ 512 .. 767 ] );
}

sub file_sig {
  my $file = shift;
  my @st = stat $file or die "Can't stat $file: $!\n";
  return join '-', @st[ 0, 1 ];
}

sub file_sha1 {
  my $file = shift;
  open my $fh, '<', $file or die "Can't read $file: $!\n";
  return Digest::SHA1->new->addfile( $fh )->hexdigest;
}

sub can_handle {
  my $f = shift;
  return 1 if $f =~ /\.(?:mp3|ogg|m4a|wma|wav|ra|aiff|flac)(?:\.gz)?$/i;
  return;
}

sub quantize {
  my $median = median( @_ );
  return map { $_ > $median ? 1 : 0 } @_;
}

sub median {
  my @sorted = sort { $a <=> $b } @_;
  return $sorted[ @sorted / 2 ];
}

sub get_db {
  my $db = shift;
  return retrieve $db if -e $db;
  return {};
}

sub put_db {
  my ( $db, $data ) = @_;
  if ( -e $db ) {
    my $bak = "$db.old";
    rename $db, $bak or die "Can't rename $db as $bak: $!\n";
  }
  store $data, $db;
}

sub usage {
  my $rc = shift;
  print STDERR "Usage: fdmf dir...\n";
  exit $rc if defined $rc;
}

sub find_prog {
  my ( $name, @path ) = @_;
  for my $p ( @path ) {
    my $try = File::Spec->catfile( $p, $name );
    return $try if -x $try;
  }
  my $bin = which( $name );
  die "Can't find $name on PATH\n" unless defined $bin;
  return $bin;
}

# vim:ts=2:sw=2:sts=2:et:ft=perl
